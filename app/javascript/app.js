
{
    /*
        Helper function
    */
    function $$(selector, scope) {
        return Array.prototype.slice.call((scope||document).querySelectorAll(selector));
    }

    function render(DOM, HTML) {
        DOM.innerHTML = HTML;
    }


    /*
        PART - TWO
        main game app
        */

    // Configuration of the game, they're constant variable
    const config = {
        startLevel: 1, // initial game level, the number is > 0
        noOfRetryAllowed: 2, // number of the retry allowed to the player, the number is > 0
        timeout: {
            handlePlayerClickButton_lightEffect: 200,
            handlePlayerClickButton_afterClick: 1000,
            sendForm: 2000,
            thankYouPage: 1000,
            animateButtonToPlayer_lightEffect: 500,
            initTheGame: 1000
        }, 
        interval: {
            animateButtonToPlayer: 850
        }
    }


    // Game state 
    let gameState = {
        level: config.startLevel, // integer number > 0
        noOfRetryAllowed: config.noOfRetryAllowed, // integer number >= 0
        possibilities: ['blue', 'red', 'yellow', 'green'], // inputs' value
        questionListBySystem: [],
        answerListByPlayer: [],
        status: null,
        allowClickWhenAnimating: false,
        duration: {
            startTime: null,
            timeId: null
        }
    };

    // Element selector
    const app = $$('#mainApp')[0];
    const gameInfoDisplayTitleEl = $$('.game--info__display__title', app)[0];
    const gameInfoLevelNumberEl = $$('.game--info__level__num', app)[0];
    const gameInfoChanceEl = $$('.game--info__chance__num', app)[0];
    const timerEl = $$('.game--info__timer__time', app)[0];
    const remainingTapEl = $$('.game--info__remaining-tap', app)[0];
    const gameInputWrapperEl = $$('.game--input-wrapper', app)[0];
    const startBtnEl = $$('#game-start-btn', app)[0];
    const retryBtnEl = $$('#game-retry-btn', app)[0];
    const welcomePageEl = $$('#welcomePage', app)[0];
    const gamePageEl = $$('#gamePage', app)[0];
    const thankYouPageEl = $$('#thankYouPage', app)[0];
    const userGameResultLevelEl = $$('#user-game-result-level', app)[0];
    const userGameResultTimeEl = $$('#user-game-result-time', app)[0];
        
    /*
        Animation function
        */

    // Add animation css class and remove it when it's done
    function toggleAnimation(el, animationClass) { 
        el.classList.add(animationClass);
        el.addEventListener('animationend', function() {
            el.classList.remove(animationClass);
        }, false);
    }

    // Drop in out effect, the duration of the animation is adjusted by the css code
    function dropInOutChanceAnimation({el, inContent, outContent}) {
        let html;
        if (inContent !== undefined  && outContent !== undefined) {
            html = `
                    <div class="game--info__chance__num__list">
                        <div>${inContent}</div>
                        <div>${outContent}</div>
                    </div>
                `;
        } 
        el.innerHTML = html;
    }

    // Light on the buttons in sequence to the player
    function animateButtonToPlayer() {
        let idx = 0;
        gameState.allowClickWhenAnimating = false;

        render(gameInfoDisplayTitleEl, `<span class='red'>System turn</span>`);

        let intervalId = setInterval(() => {
            
            // clear and return the interval 
            if (idx === gameState.questionListBySystem.length) {
                clearInterval(intervalId);
                gameState.allowClickWhenAnimating = true;
                render(gameInfoDisplayTitleEl, `<span class='green'>Your turn</span>`);
                return;
            }

            // Loop through the list generated by system 
            const buttonValue = gameState.questionListBySystem[idx];
            const el = $$(`.game-label[data-id="${buttonValue}"]`, app)[0];


            // lighting the button
            el.classList.add('on');

            setTimeout(() => {
                el.classList.remove('on');
            }, config.timeout.animateButtonToPlayer_lightEffect);

            idx++;
            
        }, config.interval.animateButtonToPlayer);

        
    }
        
    /*
        Generate the question list by providing the `possibilitiesList` and `noOfOutputThatYouWant`
        e.g. 
        INPUT:
        generateQuestionListBySystem(['blue', 'red', 'yellow', 'green'], 1);

        OUTPUT:
        ['green']
        */
    function generateQuestionListBySystem(possibilitiesList, noOfOutputThatYouWant) {
        const possibilitiesListlength = possibilitiesList.length;
        let output = [];

        for (let i = 0; i < noOfOutputThatYouWant; i++) {
            const randomNum = Math.floor(Math.random() * possibilitiesListlength);
            output.push(possibilitiesList[randomNum]);
        }
        return output;
    }
        
    // Check the play answer all questions or not
    function isPlayerAnsweredAllQuestions() {
        return gameState.answerListByPlayer.length === gameState.questionListBySystem.length;
    }

    function handlePlayerClickButton(e) {

        if ((gameState.answerListByPlayer.length >= gameState.questionListBySystem.length) || gameState.allowClickWhenAnimating === false) return;
        
        // handle the button clicked by the player
        if (e.target.tagName === "DIV" && e.target.className.indexOf('game-label') > -1) {
            const _ = e.target;
            const inputValue = _.getAttribute('data-id');

            // record player's answer        
            gameState.answerListByPlayer.push(inputValue);

            // console.log(gameState.answerListByPlayer);
            renderRemainingTap();

            // light on the button effect
            _.classList.add('on');
            setTimeout(() => {
                _.classList.remove('on');
            }, config.timeout.handlePlayerClickButton_lightEffect);
            
            if (isPlayerAnsweredAllQuestions()) {

                if (checkGameResult()) {
                    gameState.status = 'WIN';
                    gameState.level++;

                    // start the game in next level
                    setTimeout(() => {
                        initTheGame({isNewLevel: true});
                        renderRemainingTap();
                    }, config.timeout.handlePlayerClickButton_afterClick);
                    
                } else if (--gameState.noOfRetryAllowed > 0) {
                    // If the player answer the incorrect button, then the player can retry to answer. [the number of retry time based on the initial setting]
                    gameState.status = 'RETRY';

                    setTimeout(() => {
                        initTheGame({isNewLevel: false});
                        renderRemainingTap();
                    }, config.timeout.handlePlayerClickButton_afterClick)

                } else {
                    gameState.status = 'OVER';

                    setTimeout(() => {
                        renderDisplayInfo();
                    }, config.timeout.handlePlayerClickButton_afterClick);

                    
                    // Stop the timer
                    clearInterval(gameState.duration.timeId);
                    
                }
                
            } 

        }
    }

    // Reset the player's answer list
    function resetAnswerListByPlayer() {
        gameState.answerListByPlayer.length = 0;
    }

    // Check the answer of each game level 
    function checkGameResult() {
        return JSON.stringify(gameState.questionListBySystem) === JSON.stringify(gameState.answerListByPlayer);
    }


    function renderDisplayInfo() {
        
        // Show the current level
        render(gameInfoLevelNumberEl, `${gameState.level}`);

        // Show the number of chance at the first time
        if (gameState.noOfRetryAllowed === config.noOfRetryAllowed) {
            render(gameInfoChanceEl, `${gameState.noOfRetryAllowed}`);
        }

        // Add the animation to the display of current level
        if (gameState.status === 'WIN') {
            toggleAnimation(gameInfoLevelNumberEl, 'grow-animation');
        } 

        // Show the number of chance with animation
        if (gameState.status === 'OVER' || gameState.status === 'RETRY') {
            dropInOutChanceAnimation({
                el: gameInfoChanceEl, 
                inContent: `${gameState.noOfRetryAllowed}`, 
                outContent: `${gameState.noOfRetryAllowed + 1}`
            });
        }

        // If the game is finished, showing the game result and thank you message to the player
        if (gameState.status === 'OVER') {
            setTimeout(() => {
                render(gameInfoDisplayTitleEl, `<span>End</span>`);
                render(userGameResultLevelEl, gameState.level);
                render(userGameResultTimeEl, `${getGameDurationInSeconds()} seconds`);
            }, config.timeout.handlePlayerClickButton_afterClick);
            setTimeout(() => {
                gamePageEl.classList.remove('is-active');
                thankYouPageEl.classList.add('is-active');
            }, config.timeout.handlePlayerClickButton_afterClick + config.timeout.thankYouPage);
        }

        // If the play wants to have a new game after finished the game, reset the UI content of the old game
        if (gameState.status === null) {
            render(gameInfoDisplayTitleEl, '&nbsp;');
            render(timerEl, 0);
        }
        
    }

    function initTheGame({isNewLevel}) {

        resetAnswerListByPlayer();
        renderDisplayInfo();
        
        if (isNewLevel) {
            // generate new questions for next level
            gameState.questionListBySystem = generateQuestionListBySystem(gameState.possibilities, gameState.level);
            renderRemainingTap();
        } 
        
        // Light on buttons in order by System turn 
        setTimeout(() => {
            animateButtonToPlayer();
        }, config.timeout.initTheGame);
    }

    // If the play wants to have a new game after finished the game
    function resetForPlayTheGameAgain() {
        gameState.level = config.startLevel;
        gameState.status = null;
        gameState.noOfRetryAllowed = config.noOfRetryAllowed;
    }

    /*
        Timer
        */
    function initTimer() {
        gameState.duration.startTime = Date.now();

        gameState.duration.timeId = setInterval(() => {
            renderTimer();
        }, 1000);
    }

    function getGameDurationInSeconds() {
        return Math.floor((Date.now() - gameState.duration.startTime) / 1000);
    }

    function renderTimer() {
        const duration = getGameDurationInSeconds();
        render(timerEl, duration);
    }

    

    /*
        Remaining Tap
        */

    function renderRemainingTap() {
        const remainingNum = `Tap<br>${gameState.questionListBySystem.length - gameState.answerListByPlayer.length}`;
        render(remainingTapEl, remainingNum);
    }
    
    /*
        Event Handling
        */

    // Handle click or touch event by the player
    const clickOrTouchEvent = ("ontouchstart" in window) || (navigator.MaxTouchPoints > 0) || (navigator.msMaxTouchPoints > 0) ? 'touchstart' : 'click';
    
    gameInputWrapperEl.addEventListener(clickOrTouchEvent, handlePlayerClickButton);


    startBtnEl.addEventListener('click', () => {
        
        // Reset the 'level', 'state' and 'noOfRetryAllowed' if the play wants to have a new game after finished the game
        resetForPlayTheGameAgain();
        
        // Start the game
        initTheGame({isNewLevel: true});

        thankYouPageEl.classList.remove('is-active');
        welcomePageEl.classList.remove('is-active');
        gamePageEl.classList.add('is-active');
        
        initTimer();

    }, true);

    retryBtnEl.addEventListener('click', () => {

        thankYouPageEl.classList.remove('is-active');
        gamePageEl.classList.remove('is-active');
        welcomePageEl.classList.add('is-active');

    }, true);

};
